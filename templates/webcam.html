<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv8 Live Detection</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        #video-container {
            margin: 20px auto;
            max-width: 800px;
        }
        #webcam, #canvas {
            width: 100%;
            max-width: 800px;
            border: 2px solid #333;
        }
        .nav-buttons {
            margin: 20px 0;
        }
        .nav-buttons a {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 0 10px;
        }
        #detections {
            margin-top: 20px;
            text-align: left;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="nav-buttons">
        <a href="/">Image Upload</a>
        <a href="/webcam">Live Webcam</a>
    </div>
    
    <h1>YOLOv8 Live Detection</h1>
    
    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="canvas" style="display: none;"></canvas>
    </div>
    
    <div id="detections"></div>

    <button id="capture-btn" style="margin: 20px; padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Capture</button>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const detectionsDiv = document.getElementById('detections');
        const captureBtn = document.getElementById('capture-btn');
        let currentDetections = [];
        let detectionInFlight = false;
        let lastDetectTs = 0;
        const DETECT_EVERY_MS = 250; // ~4 FPS server detection
        // Downscaled offscreen canvas for detection to reduce payload/CPU
        const detCanvas = document.createElement('canvas');
        const detCtx = detCanvas.getContext('2d');
        let scaleX = 1;
        let scaleY = 1;
        
        async function captureFrame() {
            // Get the current frame from canvas
            const frameDataUrl = canvas.toDataURL('image/jpeg', 0.8);
            
            try {
                const response = await fetch('/save_frame', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        frame: frameDataUrl,
                        detections: currentDetections
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    alert('Frame captured successfully!');
                } else {
                    alert('Failed to capture frame.');
                }
            } catch (error) {
                console.error('Error capturing frame:', error);
                alert('Error capturing frame.');
            }
        }
        
        async function setupWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                video.srcObject = stream;
                
                // Set canvas size after video metadata is loaded
                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    // Choose a smaller width for server-side detection (keep aspect)
                    const targetDetWidth = Math.min(416, video.videoWidth);
                    const aspect = video.videoHeight / video.videoWidth;
                    detCanvas.width = targetDetWidth;
                    detCanvas.height = Math.round(targetDetWidth * aspect);
                    scaleX = canvas.width / detCanvas.width;
                    scaleY = canvas.height / detCanvas.height;
                });
                
                // Start detection loop
                detectFrame();
            } catch (error) {
                console.error('Error accessing webcam:', error);
                alert('Error accessing webcam. Please make sure you have a webcam connected and have granted permission to use it.');
            }
        }

        async function detectFrame() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                // Always draw live video at display FPS
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                // Draw last known detections (scaled to display canvas)
                const fontSize = Math.max(12, Math.round(canvas.height * 0.025));
                ctx.font = `${fontSize}px Arial`;
                ctx.lineWidth = Math.max(2, Math.round(canvas.height * 0.004));
                currentDetections.forEach(det => {
                    const [dx1, dy1, dx2, dy2] = det.bbox;
                    const x1 = Math.round(dx1 * scaleX);
                    const y1 = Math.round(dy1 * scaleY);
                    const x2 = Math.round(dx2 * scaleX);
                    const y2 = Math.round(dy2 * scaleY);
                    const label = `${det.class} ${(det.confidence * 100).toFixed(1)}%`;
                    ctx.strokeStyle = 'rgba(0, 255, 0, 1)';
                    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                    const textMetrics = ctx.measureText(label);
                    const textWidth = textMetrics.width + 10;
                    const textHeight = fontSize + 6;
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                    ctx.fillRect(x1, Math.max(0, y1 - textHeight), textWidth, textHeight);
                    ctx.fillStyle = '#000000';
                    ctx.fillText(label, x1 + 5, Math.max(fontSize, y1 - 6));
                });

                // Throttle detection requests and downscale
                const now = performance.now();
                if (!detectionInFlight && now - lastDetectTs >= DETECT_EVERY_MS) {
                    detectionInFlight = true;
                    lastDetectTs = now;
                    detCtx.drawImage(video, 0, 0, detCanvas.width, detCanvas.height);
                    detCanvas.toBlob(async (blob) => {
                        try {
                            const formData = new FormData();
                            formData.append('file', blob, 'frame.jpg');
                            const response = await fetch('/detect_frame', { method: 'POST', body: formData });
                            const data = await response.json();
                            // Keep detections in detCanvas coordinates
                            currentDetections = Array.isArray(data.detections) ? data.detections : [];
                            let detectionsHtml = '<h3>Detections:</h3><ul>';
                            currentDetections.forEach(det => {
                                detectionsHtml += `<li>Class: ${det.class} - Confidence: ${(det.confidence * 100).toFixed(2)}%</li>`;
                            });
                            detectionsHtml += '</ul>';
                            detectionsDiv.innerHTML = detectionsHtml;
                        } catch (err) {
                            // ignore transient errors
                        } finally {
                            detectionInFlight = false;
                        }
                    }, 'image/jpeg', 0.7);
                }

                // Show canvas and hide video for overlay
                video.style.display = 'none';
                canvas.style.display = 'block';
            }
            requestAnimationFrame(detectFrame);
        }

        // Add capture button event listener
        captureBtn.addEventListener('click', () => {
            // Scale detections to display canvas before sending to server
            const scaledDetections = currentDetections.map(det => {
                const [dx1, dy1, dx2, dy2] = det.bbox;
                return {
                    ...det,
                    bbox: [dx1 * scaleX, dy1 * scaleY, dx2 * scaleX, dy2 * scaleY]
                };
            });
            // Replace with scaled versions for this capture call
            const prev = currentDetections;
            currentDetections = scaledDetections;
            captureFrame().finally(() => { currentDetections = prev; });
        });

        // Start webcam when page loads
        setupWebcam();
    </script>
</body>
</html>